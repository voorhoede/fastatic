<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Buffer | Node.js v6.4.0 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="https://nodejs.org/api/buffer.html">
</head>
<body class="alt apidoc" id="api-section-buffer">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
          Node.js
        </a>
      </div>
      <ul>
<li><a class="nav-documentation" href="documentation.html">About these Docs</a></li>
<li><a class="nav-synopsis" href="synopsis.html">Usage &amp; Example</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a class="nav-assert" href="assert.html">Assertion Testing</a></li>
<li><a class="nav-buffer active" href="buffer.html">Buffer</a></li>
<li><a class="nav-addons" href="addons.html">C/C++ Addons</a></li>
<li><a class="nav-child_process" href="child_process.html">Child Processes</a></li>
<li><a class="nav-cluster" href="cluster.html">Cluster</a></li>
<li><a class="nav-cli" href="cli.html">Command Line Options</a></li>
<li><a class="nav-console" href="console.html">Console</a></li>
<li><a class="nav-crypto" href="crypto.html">Crypto</a></li>
<li><a class="nav-debugger" href="debugger.html">Debugger</a></li>
<li><a class="nav-dns" href="dns.html">DNS</a></li>
<li><a class="nav-domain" href="domain.html">Domain</a></li>
<li><a class="nav-errors" href="errors.html">Errors</a></li>
<li><a class="nav-events" href="events.html">Events</a></li>
<li><a class="nav-fs" href="fs.html">File System</a></li>
<li><a class="nav-globals" href="globals.html">Globals</a></li>
<li><a class="nav-http" href="http.html">HTTP</a></li>
<li><a class="nav-https" href="https.html">HTTPS</a></li>
<li><a class="nav-modules" href="modules.html">Modules</a></li>
<li><a class="nav-net" href="net.html">Net</a></li>
<li><a class="nav-os" href="os.html">OS</a></li>
<li><a class="nav-path" href="path.html">Path</a></li>
<li><a class="nav-process" href="process.html">Process</a></li>
<li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
<li><a class="nav-querystring" href="querystring.html">Query Strings</a></li>
<li><a class="nav-readline" href="readline.html">Readline</a></li>
<li><a class="nav-repl" href="repl.html">REPL</a></li>
<li><a class="nav-stream" href="stream.html">Stream</a></li>
<li><a class="nav-string_decoder" href="string_decoder.html">String Decoder</a></li>
<li><a class="nav-timers" href="timers.html">Timers</a></li>
<li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
<li><a class="nav-tty" href="tty.html">TTY</a></li>
<li><a class="nav-dgram" href="dgram.html">UDP/Datagram</a></li>
<li><a class="nav-url" href="url.html">URL</a></li>
<li><a class="nav-util" href="util.html">Utilities</a></li>
<li><a class="nav-v8" href="v8.html">V8</a></li>
<li><a class="nav-vm" href="vm.html">VM</a></li>
<li><a class="nav-zlib" href="zlib.html">ZLIB</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a class="nav-https-github-com-nodejs-node" href="https://github.com/nodejs/node">GitHub Repo &amp; Issue Tracker</a></li>
<li><a class="nav-http-groups-google-com-group-nodejs" href="http://groups.google.com/group/nodejs">Mailing List</a></li>
</ul>

    </div>

    <div id="column1" data-id="buffer" class="interior">
      <header>
        <h1>Node.js v6.4.0 Documentation</h1>
        <div id="gtoc">
          <p>
            <a href="index.html" name="toc">Index</a> |
            <a href="all.html">View on single page</a> |
            <a href="buffer.json">View as JSON</a>
          </p>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>Table of Contents</h2>
        <ul>
<li><a href="#buffer_buffer">Buffer</a><ul>
<li><a href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe"><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></a><ul>
<li><a href="#buffer_the_zero_fill_buffers_command_line_option">The <code>--zero-fill-buffers</code> command line option</a></li>
<li><a href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">What makes [<code>Buffer.allocUnsafe()</code>] and [<code>Buffer.allocUnsafeSlow()</code>] &quot;unsafe&quot;?</a></li>
</ul>
</li>
<li><a href="#buffer_buffers_and_character_encodings">Buffers and Character Encodings</a></li>
<li><a href="#buffer_buffers_and_typedarray">Buffers and TypedArray</a></li>
<li><a href="#buffer_buffers_and_es6_iteration">Buffers and ES6 iteration</a></li>
<li><a href="#buffer_class_buffer">Class: Buffer</a><ul>
<li><a href="#buffer_new_buffer_array">new Buffer(array)</a></li>
<li><a href="#buffer_new_buffer_buffer">new Buffer(buffer)</a></li>
<li><a href="#buffer_new_buffer_arraybuffer_byteoffset_length">new Buffer(arrayBuffer[, byteOffset [, length]])</a></li>
<li><a href="#buffer_new_buffer_size">new Buffer(size)</a></li>
<li><a href="#buffer_new_buffer_string_encoding">new Buffer(string[, encoding])</a></li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding">Class Method: Buffer.alloc(size[, fill[, encoding]])</a></li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size">Class Method: Buffer.allocUnsafe(size)</a></li>
<li><a href="#buffer_class_method_buffer_allocunsafeslow_size">Class Method: Buffer.allocUnsafeSlow(size)</a></li>
<li><a href="#buffer_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string[, encoding])</a></li>
<li><a href="#buffer_class_method_buffer_compare_buf1_buf2">Class Method: Buffer.compare(buf1, buf2)</a></li>
<li><a href="#buffer_class_method_buffer_concat_list_totallength">Class Method: Buffer.concat(list[, totalLength])</a></li>
<li><a href="#buffer_class_method_buffer_from_array">Class Method: Buffer.from(array)</a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length">Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])</a></li>
<li><a href="#buffer_class_method_buffer_from_buffer">Class Method: Buffer.from(buffer)</a></li>
<li><a href="#buffer_class_method_buffer_from_string_encoding">Class Method: Buffer.from(string[, encoding])</a></li>
<li><a href="#buffer_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
<li><a href="#buffer_class_method_buffer_isencoding_encoding">Class Method: Buffer.isEncoding(encoding)</a></li>
<li><a href="#buffer_class_property_buffer_poolsize">Class Property: Buffer.poolSize</a></li>
<li><a href="#buffer_buf_index">buf[index]</a></li>
<li><a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</a></li>
<li><a href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend">buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</a></li>
<li><a href="#buffer_buf_entries">buf.entries()</a></li>
<li><a href="#buffer_buf_equals_otherbuffer">buf.equals(otherBuffer)</a></li>
<li><a href="#buffer_buf_fill_value_offset_end_encoding">buf.fill(value[, offset[, end]][, encoding])</a></li>
<li><a href="#buffer_buf_indexof_value_byteoffset_encoding">buf.indexOf(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_includes_value_byteoffset_encoding">buf.includes(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_keys">buf.keys()</a></li>
<li><a href="#buffer_buf_lastindexof_value_byteoffset_encoding">buf.lastIndexOf(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_length">buf.length</a></li>
<li><a href="#buffer_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readfloatle_offset_noassert">buf.readFloatLE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readint8_offset_noassert">buf.readInt8(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readint16be_offset_noassert">buf.readInt16BE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readint16le_offset_noassert">buf.readInt16LE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readint32be_offset_noassert">buf.readInt32BE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readint32le_offset_noassert">buf.readInt32LE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readintbe_offset_bytelength_noassert">buf.readIntBE(offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_readintle_offset_bytelength_noassert">buf.readIntLE(offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_readuint8_offset_noassert">buf.readUInt8(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset[, noAssert])</a></li>
<li><a href="#buffer_buf_readuintbe_offset_bytelength_noassert">buf.readUIntBE(offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_readuintle_offset_bytelength_noassert">buf.readUIntLE(offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_slice_start_end">buf.slice([start[, end]])</a></li>
<li><a href="#buffer_buf_swap16">buf.swap16()</a></li>
<li><a href="#buffer_buf_swap32">buf.swap32()</a></li>
<li><a href="#buffer_buf_swap64">buf.swap64()</a></li>
<li><a href="#buffer_buf_tostring_encoding_start_end">buf.toString([encoding[, start[, end]]])</a></li>
<li><a href="#buffer_buf_tojson">buf.toJSON()</a></li>
<li><a href="#buffer_buf_values">buf.values()</a></li>
<li><a href="#buffer_buf_write_string_offset_length_encoding">buf.write(string[, offset[, length]][, encoding])</a></li>
<li><a href="#buffer_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeintbe_value_offset_bytelength_noassert">buf.writeIntBE(value, offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_writeintle_value_offset_bytelength_noassert">buf.writeIntLE(value, offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert">buf.writeUIntBE(value, offset, byteLength[, noAssert])</a></li>
<li><a href="#buffer_buf_writeuintle_value_offset_bytelength_noassert">buf.writeUIntLE(value, offset, byteLength[, noAssert])</a></li>
</ul>
</li>
<li><a href="#buffer_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#buffer_buffer_kmaxlength">buffer.kMaxLength</a></li>
<li><a href="#buffer_class_slowbuffer">Class: SlowBuffer</a><ul>
<li><a href="#buffer_new_slowbuffer_size">new SlowBuffer(size)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>

      <div id="apicontent">
        <h1>Buffer<span><a class="mark" href="#buffer_buffer" id="buffer_buffer">#</a></span></h1>
<pre class="api_stability api_stability_2">Stability: 2 - Stable</pre><p>Prior to the introduction of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> in ECMAScript 2015 (ES6), the
JavaScript language had no mechanism for reading or manipulating streams
of binary data. The <code>Buffer</code> class was introduced as part of the Node.js
API to make it possible to interact with octet streams in the context of things
like TCP streams and file system operations.</p>
<p>Now that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> has been added in ES6, the <code>Buffer</code> class implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js&#39;
use cases.</p>
<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but
correspond to fixed-sized, raw memory allocations outside the V8 heap.
The size of the <code>Buffer</code> is established when it is created and cannot be
resized.</p>
<p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one
would need to ever use <code>require(&#39;buffer&#39;).Buffer</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js">// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10, filled with 0x1.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using either fill() or write().
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing [0x1, 0x2, 0x3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing ASCII bytes [0x74, 0x65, 0x73, 0x74].
const buf5 = Buffer.from(&#39;test&#39;);

// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].
const buf6 = Buffer.from(&#39;tést&#39;, &#39;utf8&#39;);
</code></pre>
<h2><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code><span><a class="mark" href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe" id="buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe">#</a></span></h2>
<p>In versions of Node.js prior to v6, <code>Buffer</code> instances were created using the
<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>
differently based on what arguments are provided:</p>
<ul>
<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),
allocates a new <code>Buffer</code> object of the specified size. The memory allocated
for such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive
data</em>. Such <code>Buffer</code> instances <em>must</em> be initialized <em>manually</em> by using either
<a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or by writing to the <code>Buffer</code> completely. While
this behavior is <em>intentional</em> to improve performance, development experience
has demonstrated that a more explicit distinction is required between creating
a fast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li>
<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the
passed object&#39;s data into the <code>Buffer</code>.</li>
<li>Passing an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> returns a <code>Buffer</code> that shares allocated memory with
the given <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>.</li>
</ul>
<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type
of value passed as the first argument, applications that do not properly
validate the input arguments passed to <code>new Buffer()</code>, or that fail to
appropriately initialize newly allocated <code>Buffer</code> content, can inadvertently
introduce security and reliability issues into their code.</p>
<p>To make the creation of <code>Buffer</code> instances more reliable and less error prone,
the various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>
and replaced by separate <code>Buffer.from()</code>, <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a>, and
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> methods.</p>
<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors
to one of these new APIs.</em></p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided
octets.</li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>
returns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>.</li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the
contents of the given <code>Buffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(string[, encoding])</code></a> returns a new <code>Buffer</code>
containing a <em>copy</em> of the provided string.</li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a &quot;filled&quot;
<code>Buffer</code> instance of the specified size. This method can be significantly
slower than <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> but ensures
that newly created <code>Buffer</code> instances never contain old and potentially
sensitive data.</li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> and
<a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a
new <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized
using either <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or written to completely.</li>
</ul>
<p><code>Buffer</code> instances returned by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off
a shared internal memory pool if <code>size</code> is less than or equal to half
<a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. Instances returned by <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>
use the shared internal memory pool.</p>
<h3>The <code>--zero-fill-buffers</code> command line option<span><a class="mark" href="#buffer_the_zero_fill_buffers_command_line_option" id="buffer_the_zero_fill_buffers_command_line_option">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to
force all newly allocated <code>Buffer</code> instances created using either
<code>new Buffer(size)</code>, <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>, <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> or
<code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of
this flag <em>changes the default behavior</em> of these methods and <em>can have a significant
impact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is recommended
only when necessary to enforce that newly allocated <code>Buffer</code> instances cannot
contain potentially sensitive data.</p>
<p>Example:</p>
<pre><code class="lang-txt">$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(5);
&lt;Buffer 00 00 00 00 00&gt;
</code></pre>
<h3>What makes <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> &quot;unsafe&quot;?<span><a class="mark" href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe" id="buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">#</a></span></h3>
<p>When calling <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a>, the
segment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While
this design makes the allocation of memory quite fast, the allocated segment of
memory might contain old data that is potentially sensitive. Using a <code>Buffer</code>
created by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory
can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>
<p>While there are clear performance advantages to using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>,
extra care <em>must</em> be taken in order to avoid introducing security
vulnerabilities into an application.</p>
<h2>Buffers and Character Encodings<span><a class="mark" href="#buffer_buffers_and_character_encodings" id="buffer_buffers_and_character_encodings">#</a></span></h2>
<p><code>Buffer</code> instances are commonly used to represent sequences of encoded characters
such as UTF-8, UCS2, Base64 or even Hex-encoded data. It is possible to
convert back and forth between <code>Buffer</code> instances and ordinary JavaScript strings
by using an explicit character encoding.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;hello world&#39;, &#39;ascii&#39;);

// Prints: 68656c6c6f20776f726c64
console.log(buf.toString(&#39;hex&#39;));

// Prints: aGVsbG8gd29ybGQ=
console.log(buf.toString(&#39;base64&#39;));
</code></pre>
<p>The character encodings currently supported by Node.js include:</p>
<ul>
<li><p><code>&#39;ascii&#39;</code> - for 7-bit ASCII data only. This encoding is fast and will strip
the high bit if set.</p>
</li>
<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>
</li>
<li><p><code>&#39;base64&#39;</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,
this encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as
specified in <a href="https://tools.ietf.org/html/rfc4648#section-5">RFC4648, Section 5</a>.</p>
</li>
<li><p><code>&#39;latin1&#39;</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string
(as defined by the IANA in <a href="https://tools.ietf.org/html/rfc1345">RFC1345</a>,
page 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>
</li>
<li><p><code>&#39;binary&#39;</code> - Alias for <code>&#39;latin1&#39;</code>.</p>
</li>
<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p><em>Note</em>: Today&#39;s browsers follow the <a href="https://encoding.spec.whatwg.org/">WHATWG spec</a> which aliases both &#39;latin1&#39; and
ISO-8859-1 to win-1252. This means that while doing something like <code>http.get()</code>,
if the returned charset is one of those listed in the WHATWG spec it&#39;s possible
that the server actually returned win-1252-encoded data, and using <code>&#39;latin1&#39;</code>
encoding may incorrectly decode the characters.</p>
<h2>Buffers and TypedArray<span><a class="mark" href="#buffer_buffers_and_typedarray" id="buffer_buffers_and_typedarray">#</a></span></h2>
<p><code>Buffer</code> instances are also <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> instances. However, there are subtle
incompatibilities with the TypedArray specification in ECMAScript 2015.
For example, while <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the
implementation of <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the
existing <code>Buffer</code> without copying, making <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> far
more efficient.</p>
<p>It is also possible to create new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instances from a <code>Buffer</code> with
the following caveats:</p>
<ol>
<li><p>The <code>Buffer</code> object&#39;s memory is copied to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>, not shared.</p>
</li>
<li><p>The <code>Buffer</code> object&#39;s memory is interpreted as an array of distinct
elements, and not as a byte array of the target type. That is,
<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a>
with elements <code>[1, 2, 3, 4]</code>, not a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol>
<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as
a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance by using the TypeArray object&#39;s <code>.buffer</code> property.</p>
<p>Example:</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Copies the contents of `arr`
const buf1 = Buffer.from(arr);

// Shares memory with `arr`
const buf2 = Buffer.from(arr.buffer);

// Prints: &lt;Buffer 88 a0&gt;
console.log(buf1);

// Prints: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf2);

arr[1] = 6000;

// Prints: &lt;Buffer 88 a0&gt;
console.log(buf1);

// Prints: &lt;Buffer 88 13 70 17&gt;
console.log(buf2);
</code></pre>
<p>Note that when creating a <code>Buffer</code> using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>&#39;s <code>.buffer</code>, it is
possible to use only a portion of the underlying <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> by passing in
<code>byteOffset</code> and <code>length</code> parameters.</p>
<p>Example:</p>
<pre><code class="lang-js">const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);

// Prints: 16
console.log(buf.length);
</code></pre>
<p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from"><code>TypedArray.from()</code></a> (e.g. <code>Uint8Array.from()</code>) have
different signatures and implementations. Specifically, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> variants
accept a second argument that is a mapping function that is invoked on every
element of the typed array:</p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping
function:</p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(string[, encoding])</code></a></li>
</ul>
<h2>Buffers and ES6 iteration<span><a class="mark" href="#buffer_buffers_and_es6_iteration" id="buffer_buffers_and_es6_iteration">#</a></span></h2>
<p><code>Buffer</code> instances can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code>
syntax.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3]);

// Prints:
//   1
//   2
//   3
for (var b of buf) {
  console.log(b);
}
</code></pre>
<p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and
<a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p>
<h2>Class: Buffer<span><a class="mark" href="#buffer_class_buffer" id="buffer_class_buffer">#</a></span></h2>
<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>
<h3>new Buffer(array)<span><a class="mark" href="#buffer_new_buffer_array" id="buffer_new_buffer_array">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> instead.</pre><ul>
<li><code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type">&lt;Array&gt;</a> An array of bytes to copy from</li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<p>Example:</p>
<pre><code class="lang-js">// Creates a new Buffer containing the ASCII bytes of the string &#39;buffer&#39;
const buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<h3>new Buffer(buffer)<span><a class="mark" href="#buffer_new_buffer_buffer" id="buffer_new_buffer_buffer">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> instead.</pre><ul>
<li><code>buffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> An existing <code>Buffer</code> to copy data from</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf1 = new Buffer(&#39;buffer&#39;);
const buf2 = new Buffer(buf1);

buf1[0] = 0x61;

// Prints: auffer
console.log(buf1.toString());

// Prints: buffer
console.log(buf2.toString());
</code></pre>
<h3>new Buffer(arrayBuffer[, byteOffset [, length]])<span><a class="mark" href="#buffer_new_buffer_arraybuffer_byteoffset_length" id="buffer_new_buffer_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use
<a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>
instead.</pre><ul>
<li><code>arrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&lt;ArrayBuffer&gt;</a> The <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a></li>
<li><code>byteOffset</code> <span class="type">&lt;Integer&gt;</span> Where to start copying from <code>arrayBuffer</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> <span class="type">&lt;Integer&gt;</span> How many bytes to copy from <code>arrayBuffer</code>.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance,
the newly created <code>Buffer</code> will share the same allocated memory as the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</p>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`
const buf = new Buffer(arr.buffer);

// Prints: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf);

// Changing the original Uint16Array changes the Buffer also
arr[1] = 6000;

// Prints: &lt;Buffer 88 13 70 17&gt;
console.log(buf);
</code></pre>
<h3>new Buffer(size)<span><a class="mark" href="#buffer_new_buffer_size" id="buffer_new_buffer_size">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> instead (also see
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>).</pre><ul>
<li><code>size</code> <span class="type">&lt;Integer&gt;</span> The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than or equal
to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown.
A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>Unlike <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances
created in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>
are unknown and <em>could contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a>
to initialize a <code>Buffer</code> to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = new Buffer(5);

// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;
console.log(buf);

buf.fill(0);

// Prints: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<h3>new Buffer(string[, encoding])<span><a class="mark" href="#buffer_new_buffer_string_encoding" id="buffer_new_buffer_string_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated:
Use <a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(string[, encoding])</code></a> instead.</pre><ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> String to encode</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The encoding of <code>string</code>. <strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
</ul>
<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If
provided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = new Buffer(&#39;this is a tést&#39;);

// Prints: this is a tést
console.log(buf1.toString());

// Prints: this is a tC)st
console.log(buf1.toString(&#39;ascii&#39;));


const buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);

// Prints: this is a tést
console.log(buf2.toString());
</code></pre>
<h3>Class Method: Buffer.alloc(size[, fill[, encoding]])<span><a class="mark" href="#buffer_class_method_buffer_alloc_size_fill_encoding" id="buffer_class_method_buffer_alloc_size_fill_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>size</code> <span class="type">&lt;Integer&gt;</span> The desired length of the new <code>Buffer</code></li>
<li><code>fill</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;Integer&gt;</span> A value to pre-fill the new <code>Buffer</code> with.
<strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>fill</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the
<code>Buffer</code> will be <em>zero-filled</em>.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.alloc(5);

// Prints: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<p>The <code>size</code> must be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.
Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if
<code>size &lt;= 0</code>.</p>
<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling
<a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.alloc(5, &#39;a&#39;);

// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf);
</code></pre>
<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be
initialized by calling <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill, encoding)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);

// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;
console.log(buf);
</code></pre>
<p>Calling <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance
contents will <em>never contain sensitive data</em>.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3>Class Method: Buffer.allocUnsafe(size)<span><a class="mark" href="#buffer_class_method_buffer_allocunsafe_size" id="buffer_class_method_buffer_allocunsafe_size">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>size</code> <span class="type">&lt;Integer&gt;</span> The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes. The <code>size</code> must
be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a
<a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize such
<code>Buffer</code> instances to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(5);

// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;
console.log(buf);

buf.fill(0);

// Prints: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of
size <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new
<code>Buffer</code> instances created using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> (and the deprecated
<code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to
<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> divided by two).</p>
<p>Use of this pre-allocated internal memory pool is a key difference between
calling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.
Specifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>
pool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal
<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. The
difference is subtle but can be important when an application requires the
additional performance that <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> provides.</p>
<h3>Class Method: Buffer.allocUnsafeSlow(size)<span><a class="mark" href="#buffer_class_method_buffer_allocunsafeslow_size" id="buffer_class_method_buffer_allocunsafeslow_size">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>size</code> <span class="type">&lt;Integer&gt;</span> The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <em>non-zero-filled</em> and non-pooled <code>Buffer</code> of <code>size</code> bytes. The
<code>size</code> must be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.
Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if
<code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize such
<code>Buffer</code> instances to zeroes.</p>
<p>When using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,
allocations under 4KB are, by default, sliced from a single pre-allocated
<code>Buffer</code>. This allows applications to avoid the garbage collection overhead of
creating many individually allocated <code>Buffer</code> instances. This approach improves
both performance and memory usage by eliminating the need to track and cleanup as
many <code>Persistent</code> objects.</p>
<p>However, in the case where a developer may need to retain a small chunk of
memory from a pool for an indeterminate amount of time, it may be appropriate
to create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> then
copy out the relevant bits.</p>
<p>Example:</p>
<pre><code class="lang-js">// Need to keep around a few small chunks of memory
const store = [];

socket.on(&#39;readable&#39;, () =&gt; {
  const data = socket.read();

  // Allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);

  // Copy the data into the new allocation
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em>
a developer has observed undue memory retention in their applications.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3>Class Method: Buffer.byteLength(string[, encoding])<span><a class="mark" href="#buffer_class_method_buffer_bytelength_string_encoding" id="buffer_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div><ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;TypedArray&gt;</span> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" class="type">&lt;DataView&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&lt;ArrayBuffer&gt;</a> A value to
calculate the length of</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>string</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> The number of bytes contained within <code>string</code></li>
</ul>
<p>Returns the actual byte length of a string. This is not the same as
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in
a string.</p>
<p>Example:</p>
<pre><code class="lang-js">const str = &#39;\u00bd + \u00bc = \u00be&#39;;

// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);
</code></pre>
<p>When <code>string</code> is a <code>Buffer</code>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView"><code>DataView</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>, the
actual byte length is returned.</p>
<p>Otherwise, converts to <code>String</code> and returns the byte length of string.</p>
<h3>Class Method: Buffer.compare(buf1, buf2)<span><a class="mark" href="#buffer_class_method_buffer_compare_buf1_buf2" id="buffer_class_method_buffer_compare_buf1_buf2">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.13</span>
</div><ul>
<li><code>buf1</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
<li><code>buf2</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of
<code>Buffer</code> instances. This is equivalent to calling
<a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"><code>buf1.compare(buf2)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&#39;1234&#39;);
const buf2 = Buffer.from(&#39;0123&#39;);
const arr = [buf1, buf2];

// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
// (This result is equal to: [buf2, buf1])
console.log(arr.sort(Buffer.compare));
</code></pre>
<h3>Class Method: Buffer.concat(list[, totalLength])<span><a class="mark" href="#buffer_class_method_buffer_concat_list_totallength" id="buffer_class_method_buffer_concat_list_totallength">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.7.11</span>
</div><ul>
<li><code>list</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type">&lt;Array&gt;</a> List of <code>Buffer</code> instances to concat</li>
<li><code>totalLength</code> <span class="type">&lt;Integer&gt;</span> Total length of the <code>Buffer</code> instances in <code>list</code>
when concatenated</li>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>
instances in the <code>list</code> together.</p>
<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length
<code>Buffer</code> is returned.</p>
<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances
in <code>list</code>. This however causes an additional loop to be executed in order to
calculate the <code>totalLength</code>, so it is faster to provide the length explicitly if
it is already known.</p>
<p>Example: Create a single <code>Buffer</code> from a list of three <code>Buffer</code> instances</p>
<pre><code class="lang-js">const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

// Prints: 42
console.log(totalLength);

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

// Prints: &lt;Buffer 00 00 00 00 ...&gt;
console.log(bufA);

// Prints: 42
console.log(bufA.length);
</code></pre>
<h3>Class Method: Buffer.from(array)<span><a class="mark" href="#buffer_class_method_buffer_from_array" id="buffer_class_method_buffer_from_array">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type">&lt;Array&gt;</a></li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<p>Example:</p>
<pre><code class="lang-js">// Creates a new Buffer containing ASCII bytes of the string &#39;buffer&#39;
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>
<h3>Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])<span><a class="mark" href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length" id="buffer_class_method_buffer_from_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>arrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&lt;ArrayBuffer&gt;</a> The <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a></li>
<li><code>byteOffset</code> <span class="type">&lt;Integer&gt;</span> Where to start copying from <code>arrayBuffer</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> <span class="type">&lt;Integer&gt;</span> How many bytes to copy from <code>arrayBuffer</code>.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance,
the newly created <code>Buffer</code> will share the same allocated memory as the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`
const buf = Buffer.from(arr.buffer);

// Prints: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf);

// Changing the original Uint16Array changes the Buffer also
arr[1] = 6000;

// Prints: &lt;Buffer 88 13 70 17&gt;
console.log(buf);
</code></pre>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js">const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);

// Prints: 2
console.log(buf.length);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>.</p>
<h3>Class Method: Buffer.from(buffer)<span><a class="mark" href="#buffer_class_method_buffer_from_buffer" id="buffer_class_method_buffer_from_buffer">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>buffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> An existing <code>Buffer</code> to copy data from</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&#39;buffer&#39;);
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

// Prints: auffer
console.log(buf1.toString());

// Prints: buffer
console.log(buf2.toString());
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>
<h3>Class Method: Buffer.from(string[, encoding])<span><a class="mark" href="#buffer_class_method_buffer_from_string_encoding" id="buffer_class_method_buffer_from_string_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> A string to encode.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The encoding of <code>string</code>. <strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
</ul>
<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If
provided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&#39;this is a tést&#39;);

// Prints: this is a tést
console.log(buf1.toString());

// Prints: this is a tC)st
console.log(buf1.toString(&#39;ascii&#39;));


const buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);

// Prints: this is a tést
console.log(buf2.toString());
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>
<h3>Class Method: Buffer.isBuffer(obj)<span><a class="mark" href="#buffer_class_method_buffer_isbuffer_obj" id="buffer_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.101</span>
</div><ul>
<li><code>obj</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a></li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a></li>
</ul>
<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>
<h3>Class Method: Buffer.isEncoding(encoding)<span><a class="mark" href="#buffer_class_method_buffer_isencoding_encoding" id="buffer_class_method_buffer_isencoding_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.9.1</span>
</div><ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> A character encoding name to check</li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a></li>
</ul>
<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>
otherwise.</p>
<h3>Class Property: Buffer.poolSize<span><a class="mark" href="#buffer_class_property_buffer_poolsize" id="buffer_class_property_buffer_poolsize">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.3</span>
</div><ul>
<li><span class="type">&lt;Integer&gt;</span> <strong>Default:</strong> <code>8192</code></li>
</ul>
<p>This is the number of bytes used to determine the size of pre-allocated, internal
<code>Buffer</code> instances used for pooling. This value may be modified.</p>
<h3>buf[index]<span><a class="mark" href="#buffer_buf_index" id="buffer_buf_index">#</a></span></h3>
<div class="api_metadata">
</div><p>The index operator <code>[index]</code> can be used to get and set the octet at position
<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value
range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>
<p>Example: Copy an ASCII string into a <code>Buffer</code>, one byte at a time</p>
<pre><code class="lang-js">const str = &#39;Node.js&#39;;
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

// Prints: Node.js
console.log(buf.toString(&#39;ascii&#39;));
</code></pre>
<h3>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])<span><a class="mark" href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend" id="buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.13</span>
</div><ul>
<li><code>target</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A <code>Buffer</code> to compare to</li>
<li><code>targetStart</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>target</code> at which to begin
comparison. <strong>Default:</strong> <code>0</code></li>
<li><code>targetEnd</code> <span class="type">&lt;Integer&gt;</span> The offset with <code>target</code> at which to end comparison
(not inclusive). Ignored when <code>targetStart</code> is <code>undefined</code>.
<strong>Default:</strong> <code>target.length</code></li>
<li><code>sourceStart</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>buf</code> at which to begin comparison.
Ignored when <code>targetStart</code> is <code>undefined</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceEnd</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>buf</code> at which to end comparison
(not inclusive). Ignored when <code>targetStart</code> is <code>undefined</code>.
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>
comes before, after, or is the same as <code>target</code> in sort order.
Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>
<ul>
<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>
<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>
<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>
</ul>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;BCD&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

// Prints: 0
console.log(buf1.compare(buf1));

// Prints: -1
console.log(buf1.compare(buf2));

// Prints: -1
console.log(buf1.compare(buf3));

// Prints: 1
console.log(buf2.compare(buf1));

// Prints: 1
console.log(buf2.compare(buf3));

// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
// (This result is equal to: [buf1, buf3, buf2])
console.log([buf1, buf2, buf3].sort(Buffer.compare));
</code></pre>
<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>
arguments can be used to limit the comparison to specific ranges within <code>target</code>
and <code>buf</code> respectively.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

// Prints: 0
console.log(buf1.compare(buf2, 5, 9, 0, 4));

// Prints: -1
console.log(buf1.compare(buf2, 0, 6, 4));

// Prints: 1
console.log(buf1.compare(buf2, 5, 6, 5));
</code></pre>
<p>A <code>RangeError</code> will be thrown if: <code>targetStart &lt; 0</code>, <code>sourceStart &lt; 0</code>,
<code>targetEnd &gt; target.byteLength</code> or <code>sourceEnd &gt; source.byteLength</code>.</p>
<h3>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])<span><a class="mark" href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend" id="buffer_buf_copy_target_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div><ul>
<li><code>target</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A <code>Buffer</code> to copy into.</li>
<li><code>targetStart</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>target</code> at which to begin
copying to. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceStart</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>buf</code> at which to begin copying from.
Ignored when <code>targetStart</code> is <code>undefined</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceEnd</code> <span class="type">&lt;Integer&gt;</span> The offset within <code>buf</code> at which to stop copying (not
inclusive). Ignored when <code>sourceStart</code> is <code>undefined</code>. <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> The number of bytes copied.</li>
</ul>
<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>
memory region overlaps with <code>buf</code>.</p>
<p>Example: Create two <code>Buffer</code> instances, <code>buf1</code> and <code>buf2</code>, and copy <code>buf1</code> from
byte 16 through byte 19 into <code>buf2</code>, starting at the 8th byte in <code>buf2</code></p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);

for (let i = 0 ; i &lt; 26 ; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

buf1.copy(buf2, 8, 16, 20);

// Prints: !!!!!!!!qrst!!!!!!!!!!!!!
console.log(buf2.toString(&#39;ascii&#39;, 0, 25));
</code></pre>
<p>Example: Create a single <code>Buffer</code> and copy data from one region to an
overlapping region within the same <code>Buffer</code></p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

// Prints: efghijghijklmnopqrstuvwxyz
console.log(buf.toString());
</code></pre>
<h3>buf.entries()<span><a class="mark" href="#buffer_buf_entries" id="buffer_buf_entries">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div><ul>
<li>Return: <span class="type">&lt;Iterator&gt;</span></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>[index, byte]</code> pairs from the contents of
<code>buf</code>.</p>
<p>Example: Log the entire contents of a <code>Buffer</code></p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
for (var pair of buf.entries()) {
  console.log(pair);
}
</code></pre>
<h3>buf.equals(otherBuffer)<span><a class="mark" href="#buffer_buf_equals_otherbuffer" id="buffer_buf_equals_otherbuffer">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.13</span>
</div><ul>
<li><code>otherBuffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A <code>Buffer</code> to compare to</li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a></li>
</ul>
<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,
<code>false</code> otherwise.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

// Prints: true
console.log(buf1.equals(buf2));

// Prints: false
console.log(buf1.equals(buf3));
</code></pre>
<h3>buf.fill(value[, offset[, end]][, encoding])<span><a class="mark" href="#buffer_buf_fill_value_offset_end_encoding" id="buffer_buf_fill_value_offset_end_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.0</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;Integer&gt;</span> The value to fill <code>buf</code> with</li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start filling <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> <span class="type">&lt;Integer&gt;</span> Where to stop filling <code>buf</code> (not inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A reference to <code>buf</code></li>
</ul>
<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled. This is meant to be a small simplification to
allow the creation and filling of a <code>Buffer</code> to be done on a single line.</p>
<p>Example: Fill a <code>Buffer</code> with the ASCII character <code>&#39;h&#39;</code></p>
<pre><code class="lang-js">const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);

// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
console.log(b.toString());
</code></pre>
<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a String or Integer.</p>
<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,
then only the first bytes of that character that fit into <code>buf</code> are written.</p>
<p>Example: Fill a <code>Buffer</code> with a two-byte character</p>
<pre><code class="lang-js">// Prints: &lt;Buffer c8 a2 c8&gt;
console.log(Buffer.allocUnsafe(3).fill(&#39;\u0222&#39;));
</code></pre>
<h3>buf.indexOf(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_indexof_value_byteoffset_encoding" id="buffer_buf_indexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.5.0</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;Integer&gt;</span> What to search for</li>
<li><code>byteOffset</code> <span class="type">&lt;Integer&gt;</span> Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> The index of the first occurrence of <code>value</code> in <code>buf</code> or <code>-1</code>
if <code>buf</code> does not contain <code>value</code></li>
</ul>
<p>If <code>value</code> is:</p>
<ul>
<li>a string, <code>value</code> is interpreted according to the character encoding in
<code>encoding</code>.</li>
<li>a <code>Buffer</code>, <code>value</code> will be used in its entirety. To compare a partial
<code>Buffer</code> use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>.</li>
<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer
value between <code>0</code> and <code>255</code>.</li>
</ul>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;this is a buffer&#39;);

// Prints: 0
console.log(buf.indexOf(&#39;this&#39;)));

// Prints: 2
console.log(buf.indexOf(&#39;is&#39;));

// Prints: 8
console.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));

// Prints: 8
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.indexOf(97));

// Prints: -1
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));

// Prints: 8
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));


const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;ucs2&#39;);

// Prints: 4
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, 0, &#39;ucs2&#39;));

// Prints: 6
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, -4, &#39;ucs2&#39;));
</code></pre>
<h3>buf.includes(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_includes_value_byteoffset_encoding" id="buffer_buf_includes_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.3.0</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;Integer&gt;</span> What to search for</li>
<li><code>byteOffset</code> <span class="type">&lt;Integer&gt;</span> Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> <code>true</code> if <code>value</code> was found in <code>buf</code>, <code>false</code> otherwise</li>
</ul>
<p>Equivalent to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf() !== -1</code></a>.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;this is a buffer&#39;);

// Prints: true
console.log(buf.includes(&#39;this&#39;));

// Prints: true
console.log(buf.includes(&#39;is&#39;));

// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));

// Prints: true
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.includes(97));

// Prints: false
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));

// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));

// Prints: false
console.log(buf.includes(&#39;this&#39;, 4));
</code></pre>
<h3>buf.keys()<span><a class="mark" href="#buffer_buf_keys" id="buffer_buf_keys">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div><ul>
<li>Return: <span class="type">&lt;Iterator&gt;</span></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>buf</code> keys (indices).</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   0
//   1
//   2
//   3
//   4
//   5
for (var key of buf.keys()) {
  console.log(key);
}
</code></pre>
<h3>buf.lastIndexOf(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_lastindexof_value_byteoffset_encoding" id="buffer_buf_lastindexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v6.0.0</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;Integer&gt;</span> What to search for</li>
<li><code>byteOffset</code> <span class="type">&lt;Integer&gt;</span> Where to begin searching in <code>buf</code> (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> The index of the last occurrence of <code>value</code> in <code>buf</code> or <code>-1</code>
if <code>buf</code> does not contain <code>value</code></li>
</ul>
<p>Identical to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf()</code></a>, except <code>buf</code> is searched from back to front
instead of front to back.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;this buffer is a buffer&#39;);

// Prints: 0
console.log(buf.lastIndexOf(&#39;this&#39;));

// Prints: 17
console.log(buf.lastIndexOf(&#39;buffer&#39;));

// Prints: 17
console.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));

// Prints: 15
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.lastIndexOf(97));

// Prints: -1
console.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));

// Prints: 5
console.log(buf.lastIndexOf(&#39;buffer&#39;, 5));

// Prints: -1
console.log(buf.lastIndexOf(&#39;buffer&#39;, 4));


const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;ucs2&#39;);

// Prints: 6
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, null, &#39;ucs2&#39;));

// Prints: 4
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, -5, &#39;ucs2&#39;));
</code></pre>
<h3>buf.length<span><a class="mark" href="#buffer_buf_length" id="buffer_buf_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div><ul>
<li><span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this
does not necessarily reflect the amount of &quot;usable&quot; data within <code>buf</code>.</p>
<p>Example: Create a <code>Buffer</code> and write a shorter ASCII string to it</p>
<pre><code class="lang-js">const buf = Buffer.alloc(1234);

// Prints: 1234
console.log(buf.length);

buf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);

// Prints: 1234
console.log(buf.length);
</code></pre>
<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and
use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js">var buf = Buffer.allocUnsafe(10);

buf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);

// Prints: 10
console.log(buf.length);

buf = buf.slice(0, 5);

// Prints: 5
console.log(buf.length);
</code></pre>
<h3>buf.readDoubleBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublebe_offset_noassert" id="buffer_buf_readdoublebe_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublele_offset_noassert" id="buffer_buf_readdoublele_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
</ul>
<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

// Prints: 8.20788039913184e-304
console.log(buf.readDoubleBE());

// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readDoubleLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readDoubleLE(1, true));
</code></pre>
<h3>buf.readFloatBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatbe_offset_noassert" id="buffer_buf_readfloatbe_offset_noassert">#</a></span></h3>
<h3>buf.readFloatLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatle_offset_noassert" id="buffer_buf_readfloatle_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
</ul>
<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

// Prints: 2.387939260590663e-38
console.log(buf.readFloatBE());

// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readFloatLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readFloatLE(1, true));
</code></pre>
<h3>buf.readInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint8_offset_noassert" id="buffer_buf_readint8_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.0</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([-1, 5]);

// Prints: -1
console.log(buf.readInt8(0));

// Prints: 5
console.log(buf.readInt8(1));

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt8(2));
</code></pre>
<h3>buf.readInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16be_offset_noassert" id="buffer_buf_readint16be_offset_noassert">#</a></span></h3>
<h3>buf.readInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16le_offset_noassert" id="buffer_buf_readint16le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 5]);

// Prints: 5
console.log(buf.readInt16BE());

// Prints: 1280
console.log(buf.readInt16LE(1));

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt16LE(1));
</code></pre>
<h3>buf.readInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32be_offset_noassert" id="buffer_buf_readint32be_offset_noassert">#</a></span></h3>
<h3>buf.readInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32le_offset_noassert" id="buffer_buf_readint32le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

// Prints: 5
console.log(buf.readInt32BE());

// Prints: 83886080
console.log(buf.readInt32LE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt32LE(1));
</code></pre>
<h3>buf.readIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintbe_offset_bytelength_noassert" id="buffer_buf_readintbe_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.readIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintle_offset_bytelength_noassert" id="buffer_buf_readintle_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> <span class="type">&lt;Integer&gt;</span> How many bytes to read. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> and <code>byteLength</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: 1234567890ab
console.log(buf.readIntLE(0, 6).toString(16));

// Prints: -546f87a9cbee
console.log(buf.readIntBE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readIntBE(1, 6).toString(16));
</code></pre>
<h3>buf.readUInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint8_offset_noassert" id="buffer_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.0</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([1, -2]);

// Prints: 1
console.log(buf.readUInt8(0));

// Prints: 254
console.log(buf.readUInt8(1));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt8(2));
</code></pre>
<h3>buf.readUInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16be_offset_noassert" id="buffer_buf_readuint16be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16le_offset_noassert" id="buffer_buf_readuint16le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

// Prints: 1234
console.log(buf.readUInt16BE(0).toString(16));

// Prints: 3412
console.log(buf.readUInt16LE(0).toString(16));

// Prints: 3456
console.log(buf.readUInt16BE(1).toString(16));

// Prints: 5634
console.log(buf.readUInt16LE(1).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt16LE(2).toString(16));
</code></pre>
<h3>buf.readUInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32be_offset_noassert" id="buffer_buf_readuint32be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32le_offset_noassert" id="buffer_buf_readuint32le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

// Prints: 12345678
console.log(buf.readUInt32BE(0).toString(16));

// Prints: 78563412
console.log(buf.readUInt32LE(0).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt32LE(1).toString(16));
</code></pre>
<h3>buf.readUIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintbe_offset_bytelength_noassert" id="buffer_buf_readuintbe_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.readUIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintle_offset_bytelength_noassert" id="buffer_buf_readuintle_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> <span class="type">&lt;Integer&gt;</span> How many bytes to read. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>offset</code> and <code>byteLength</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span></li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: 1234567890ab
console.log(buf.readUIntLE(0, 6).toString(16));

// Prints: ab9078563412
console.log(buf.readUIntBE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUIntBE(1, 6).toString(16));
</code></pre>
<h3>buf.slice([start[, end]])<span><a class="mark" href="#buffer_buf_slice_start_end" id="buffer_buf_slice_start_end">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.3.0</span>
</div><ul>
<li><code>start</code> <span class="type">&lt;Integer&gt;</span> Where the new <code>Buffer</code> will start. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> <span class="type">&lt;Integer&gt;</span> Where the new <code>Buffer</code> will end (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</p>
<p><strong>Note that modifying the new <code>Buffer</code> slice will modify the memory in the
original <code>Buffer</code> because the allocated memory of the two objects overlap.</strong></p>
<p>Example: Create a <code>Buffer</code> with the ASCII alphabet, take a slice, and then modify
one byte from the original <code>Buffer</code></p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

const buf2 = buf1.slice(0, 3);

// Prints: abc
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));

buf1[0] = 33;

// Prints: !bc
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
</code></pre>
<p>Specifying negative indexes causes the slice to be generated relative to the
end of <code>buf</code> rather than the beginning.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints: buffe
// (Equivalent to buf.slice(0, 5))
console.log(buf.slice(-6, -1).toString());

// Prints: buff
// (Equivalent to buf.slice(0, 4))
console.log(buf.slice(-6, -2).toString());

// Prints: uff
// (Equivalent to buf.slice(1, 4))
console.log(buf.slice(-5, -2).toString());
</code></pre>
<h3>buf.swap16()<span><a class="mark" href="#buffer_buf_swap16" id="buffer_buf_swap16">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 2.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap16();

// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 16-bits
buf2.swap32();
</code></pre>
<h3>buf.swap32()<span><a class="mark" href="#buffer_buf_swap32" id="buffer_buf_swap32">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div><ul>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 4.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap32();

// Prints &lt;Buffer 04 03 02 01 08 07 06 05&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 32-bits
buf2.swap32();
</code></pre>
<h3>buf.swap64()<span><a class="mark" href="#buffer_buf_swap64" id="buffer_buf_swap64">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v6.3.0</span>
</div><ul>
<li>Return: <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps the byte-order <em>in-place</em>.
Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 8.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap64();

// Prints &lt;Buffer 08 07 06 05 04 03 02 01&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 64-bits
buf2.swap64();
</code></pre>
<p>Note that JavaScript cannot encode 64-bit integers. This method is intended
for working with 64-bit floats.</p>
<h3>buf.toString([encoding[, start[, end]]])<span><a class="mark" href="#buffer_buf_tostring_encoding_start_end" id="buffer_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div><ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The character encoding to decode to. <strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li><code>start</code> <span class="type">&lt;Integer&gt;</span> Where to start decoding. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> <span class="type">&lt;Integer&gt;</span> Where to stop decoding (not inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a></li>
</ul>
<p>Decodes <code>buf</code> to a string according to the specified character encoding in <code>encoding</code>.
<code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf.toString(&#39;ascii&#39;));

// Prints: abcde
console.log(buf.toString(&#39;ascii&#39;, 0, 5));


const buf2 = Buffer.from(&#39;tést&#39;);

// Prints: tés
console.log(buf.toString(&#39;utf8&#39;, 0, 3));

// Prints: tés
console.log(buf.toString(undefined, 0, 3));
</code></pre>
<h3>buf.toJSON()<span><a class="mark" href="#buffer_buf_tojson" id="buffer_buf_tojson">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.9.2</span>
</div><ul>
<li>Return: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a></li>
</ul>
<p>Returns a JSON representation of <code>buf</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> implicitly calls
this function when stringifying a <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
console.log(json);

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &#39;Buffer&#39;
    ? Buffer.from(value.data)
    : value;
});

// Prints: &lt;Buffer 01 02 03 04 05&gt;
console.log(copy);
</code></pre>
<h3>buf.values()<span><a class="mark" href="#buffer_buf_values" id="buffer_buf_values">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div><ul>
<li>Return: <span class="type">&lt;Iterator&gt;</span></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> for <code>buf</code> values (bytes). This function is
called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
for (var value of buf.values()) {
  console.log(value);
}

// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
for (var value of buf) {
  console.log(value);
}
</code></pre>
<h3>buf.write(string[, offset[, length]][, encoding])<span><a class="mark" href="#buffer_buf_write_string_offset_length_encoding" id="buffer_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div><ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> String to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing <code>string</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> <span class="type">&lt;Integer&gt;</span> How many bytes to write. <strong>Default:</strong> <code>buf.length - offset</code></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The character encoding of <code>string</code>. <strong>Default:</strong> <code>&#39;utf8&#39;</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> Number of bytes written</li>
</ul>
<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in <code>encoding</code>.
The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did not contain
enough space to fit the entire string, only a partial amount of <code>string</code> will
be written. However, partially encoded characters will not be written.</p>
<p>Example:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(256);

const len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);

// Prints: 12 bytes: ½ + ¼ = ¾
console.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);
</code></pre>
<h3>buf.writeDoubleBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublebe_value_offset_noassert" id="buffer_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublele_value_offset_noassert" id="buffer_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
console.log(buf);
</code></pre>
<h3>buf.writeFloatBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatbe_value_offset_noassert" id="buffer_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatle_value_offset_noassert" id="buffer_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

// Prints: &lt;Buffer 4f 4a fe bb&gt;
console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

// Prints: &lt;Buffer bb fe 4a 4f&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint8_value_offset_noassert" id="buffer_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.0</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

// Prints: &lt;Buffer 02 fe&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16be_value_offset_noassert" id="buffer_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16le_value_offset_noassert" id="buffer_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 16-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

// Prints: &lt;Buffer 01 02 04 03&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32be_value_offset_noassert" id="buffer_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32le_value_offset_noassert" id="buffer_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 32-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
console.log(buf);
</code></pre>
<h3>buf.writeIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintbe_value_offset_bytelength_noassert" id="buffer_buf_writeintbe_value_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.writeIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintle_value_offset_bytelength_noassert" id="buffer_buf_writeintle_value_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.15</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> <span class="type">&lt;Integer&gt;</span> How many bytes to write. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code>, <code>offset</code>, and <code>byteLength</code> validation?
<strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeUIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint8_value_offset_noassert" id="buffer_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.0</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

// Prints: &lt;Buffer 03 04 23 42&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16be_value_offset_noassert" id="buffer_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16le_value_offset_noassert" id="buffer_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

// Prints: &lt;Buffer de ad be ef&gt;
console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

// Prints: &lt;Buffer ad de ef be&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32be_value_offset_noassert" id="buffer_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32le_value_offset_noassert" id="buffer_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

// Prints: &lt;Buffer fe ed fa ce&gt;
console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

// Prints: &lt;Buffer ce fa ed fe&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert" id="buffer_buf_writeuintbe_value_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.writeUIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintle_value_offset_bytelength_noassert" id="buffer_buf_writeuintle_value_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.5.5</span>
</div><ul>
<li><code>value</code> <span class="type">&lt;Integer&gt;</span> Number to be written to <code>buf</code></li>
<li><code>offset</code> <span class="type">&lt;Integer&gt;</span> Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> <span class="type">&lt;Integer&gt;</span> How many bytes to write. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Skip <code>value</code>, <code>offset</code>, and <code>byteLength</code> validation?
<strong>Default:</strong> <code>false</code></li>
<li>Return: <span class="type">&lt;Integer&gt;</span> <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeUIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#buffer_buffer_inspect_max_bytes" id="buffer_buffer_inspect_max_bytes">#</a></span></h2>
<div class="api_metadata">
<span>Added in: v0.5.4</span>
</div><ul>
<li><span class="type">&lt;Integer&gt;</span> <strong>Default:</strong> <code>50</code></li>
</ul>
<p>Returns the maximum number of bytes that will be returned when
<code>buf.inspect()</code> is called. This can be overridden by user modules. See
<a href="util.html#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>
<p>Note that this is a property on the <code>buffer</code> module as returned by
<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h2>buffer.kMaxLength<span><a class="mark" href="#buffer_buffer_kmaxlength" id="buffer_buffer_kmaxlength">#</a></span></h2>
<div class="api_metadata">
<span>Added in: v3.0.0</span>
</div><ul>
<li><span class="type">&lt;Integer&gt;</span> The largest size allowed for a single <code>Buffer</code> instance</li>
</ul>
<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).
On 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#buffer_class_slowbuffer" id="buffer_class_slowbuffer">#</a></span></h2>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> instead.</pre><p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a
single larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time, it may be appropriate to create an
un-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>
<p>Example:</p>
<pre><code class="lang-js">// Need to keep around a few small chunks of memory
const store = [];

socket.on(&#39;readable&#39;, () =&gt; {
  const data = socket.read();

  // Allocate for retained data
  const sb = SlowBuffer(10);

  // Copy the data into the new allocation
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer
has observed undue memory retention in their applications.</p>
<h3>new SlowBuffer(size)<span><a class="mark" href="#buffer_new_slowbuffer_size" id="buffer_new_slowbuffer_size">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0 </span>
</div><pre class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> instead.</pre><ul>
<li><code>size</code> <span class="type">&lt;Integer&gt;</span> The desired length of the new <code>SlowBuffer</code></li>
</ul>
<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes. The <code>size</code> must be less than
or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is
thrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The
contents of a newly created <code>SlowBuffer</code> are unknown and could contain
sensitive data. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;

const buf = new SlowBuffer(5);

// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;
console.log(buf);

buf.fill(0);

// Prints: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>

      </div>
    </div>
  </div>
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>

